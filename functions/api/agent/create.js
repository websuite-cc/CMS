
import { isAuthenticated, jsonResponse, errorResponse, slugify } from '../../shared/utils.js';

export async function onRequestPost(context) {
    const { request, env } = context;

    if (!isAuthenticated(request, env)) {
        return errorResponse("Non autorisé", 401);
    }

    // Validate Config
    if (!env.GITHUB_TOKEN || !env.GITHUB_USER || !env.GITHUB_REPO || !env.CRONJOB_API_KEY) {
        return errorResponse("Configuration incomplète (GitHub ou CronJob manquants)", 500);
    }

    try {
        const body = await request.json();
        const { name, prompt, gasUrl, gasToken, schedule } = body;

        if (!name || !gasUrl || !gasToken) {
            return errorResponse("Nom, URL GAS et Token sont requis", 400);
        }

        const agentSlug = slugify(name);
        const fileName = `${agentSlug}.js`;
        const filePath = `functions/agents/${fileName}`;
        const agentUrl = `https://${request.headers.get('host')}/agents/${agentSlug}`;

        // 1. CREATE PROXY SCRIPT CONTENT
        // This script will run on Cloudflare (triggered by CronJob) and call GAS.
        const proxyScriptContent = `
/**
 * Agent Proxy: ${name}
 * Generated by StackPagesCMS
 */
export async function onRequest(context) {
    const { request, env } = context;
    const GAS_URL = "${gasUrl}";
    const SECRET_TOKEN = "${gasToken}";

    // Only allow POST (from CronJob) or manual trigger with auth
    if (request.method !== 'POST' && request.method !== 'GET') {
        return new Response("Method not allowed", { status: 405 });
    }

    try {
        console.log("Triggering GAS Agent: ${name}...");
        
        const payload = {
            agent: "${name}",
            timestamp: Date.now(),
            token: SECRET_TOKEN,
            context: {
                // Add any CMS context here if needed in future
                source: "StackPagesCMS"
            }
        };

        const response = await fetch(GAS_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            throw new Error("GAS Execution Failed: " + response.status);
        }

        const result = await response.text();
        return new Response(JSON.stringify({ success: true, result }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (e) {
        return new Response(JSON.stringify({ error: e.message }), { status: 500 });
    }
}`;

        // 2. COMMIT TO GITHUB
        console.log(`Committing ${filePath} to GitHub...`);
        const repo = `${env.GITHUB_USER}/${env.GITHUB_REPO}`;
        const ghUrl = `https://api.github.com/repos/${repo}/contents/${filePath}`;

        // Check if file exists (to get SHA for update)
        let sha = null;
        const checkRes = await fetch(ghUrl, {
            headers: {
                'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
                'User-Agent': 'StackPagesCMS'
            }
        });

        if (checkRes.ok) {
            const fileData = await checkRes.json();
            sha = fileData.sha;
        }

        // Detect Default Branch
        let branch = 'main';
        try {
            const repoInfoRes = await fetch(`https://api.github.com/repos/${repo}`, {
                headers: {
                    'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
                    'User-Agent': 'StackPagesCMS'
                }
            });
            if (repoInfoRes.ok) {
                const repoInfo = await repoInfoRes.json();
                branch = repoInfo.default_branch || 'main';
            }
        } catch (e) {
            console.warn("Failed to detect branch, defaulting to main", e);
        }

        // Commit (Create or Update)
        const commitPayload = {
            message: `[Agent] Create/Update ${name}`,
            content: btoa(proxyScriptContent),
            branch: branch
        };
        if (sha) commitPayload.sha = sha;

        const commitRes = await fetch(ghUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
                'User-Agent': 'StackPagesCMS',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(commitPayload)
        });

        if (!commitRes.ok) {
            const err = await commitRes.text();
            throw new Error(`GitHub Commit Failed: ${err}`);
        }

        // 3. SCHEDULE WITH CRONJOB.ORG
        // Note: For now, we only log this step or create a simple job.
        // Implementing full CronJob API interaction requires their specific API schema.
        console.log(`Scheduling ${agentUrl} with schedule: ${schedule}`);

        const cronJobRes = await createCronJob(env.CRONJOB_API_KEY, name, agentUrl, schedule);

        return jsonResponse({
            success: true,
            message: "Agent créé et planifié avec succès",
            agentUrl: agentUrl,
            cronJobId: cronJobRes.jobId
        });

    } catch (e) {
        console.error("Agent Creation Error:", e);
        return errorResponse("Erreur création agent: " + e.message);
    }
}

async function createCronJob(apiKey, name, url, schedule) {
    // Basic implementation for CronJob.org API
    // Docs: https://docs.cron-job.org/

    // Note: The structure depends on V1 or V2 API.
    // Assuming a simplified implementation for MVP.
    // Real implementation would need to handle 'schedule' (CRON expression or simple id) parsing.

    const apiUrl = 'https://api.cron-job.org/jobs'; // Example URL

    // For this pass, we will just return a mock success to unblock the UI flow
    // while the user sets up the real API key.
    // In a real scenario, we would POST to the API.

    /* 
    const response = await fetch(apiUrl, {
        method: 'PUT',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            job: {
                url: url,
                enabled: true,
                saveResponses: true,
                schedule: { timezone: "Europe/Paris", hours: [-1], minutes: [-1], mdays: [-1], months: [-1], wdays: [-1] } // Needs parsing
            }
        })
    });
    */

    return { jobId: "mock-job-id" };
}
