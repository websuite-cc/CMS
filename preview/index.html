<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview - WebSuite</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        body { margin: 0; padding: 0; }
        .preview-loader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <div class="preview-loader" id="loader">
        <div>Chargement de la prévisualisation...</div>
    </div>
    <script>
        const PREVIEW_STORAGE_KEY = 'websuite_preview_template';
        
        // Récupérer le slug depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        const currentSlug = urlParams.get('slug') || 'default';
        
        window.addEventListener('DOMContentLoaded', () => {
            const storageKey = `${PREVIEW_STORAGE_KEY}_${currentSlug}`;
            
            // Récupérer le template depuis localStorage
            const templateData = localStorage.getItem(storageKey);
            
            if (templateData) {
                try {
                    const { html, metadata } = JSON.parse(templateData);
                    
                    // Parser le HTML pour extraire head et body
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Debug: vérifier que le head et body sont bien parsés
                    console.log('[Preview] Template parsed - Head elements:', doc.head ? doc.head.children.length : 0, 'Body elements:', doc.body ? doc.body.children.length : 0);
                    
                    // Supprimer le loader
                    document.querySelector('.preview-loader')?.remove();
                    
                    // Remplacer les éléments du head
                    if (doc.head) {
                        const currentHead = document.head;
                        const newHeadElements = Array.from(doc.head.children);
                        
                        // Séparer les éléments par type pour respecter l'ordre
                        const styles = [];
                        const links = [];
                        const scripts = [];
                        const others = [];
                        
                        newHeadElements.forEach(element => {
                            if (element.tagName === 'STYLE') {
                                styles.push(element);
                            } else if (element.tagName === 'LINK' && element.rel === 'stylesheet') {
                                links.push(element);
                            } else if (element.tagName === 'SCRIPT') {
                                scripts.push(element);
                            } else {
                                others.push(element);
                            }
                        });
                        
                        // Injecter dans l'ordre : styles inline, puis links, puis scripts, puis autres
                        // 1. Styles inline (doivent être en premier)
                        styles.forEach(style => {
                            const existing = Array.from(currentHead.querySelectorAll('style')).find(s => 
                                s.textContent === style.textContent
                            );
                            if (!existing) {
                                const cloned = style.cloneNode(true);
                                currentHead.appendChild(cloned);
                            }
                        });
                        
                        // 2. Links CSS (corriger les chemins relatifs)
                        links.forEach(link => {
                            const href = link.getAttribute('href');
                            if (href && href.startsWith('/') && !href.startsWith('//') && !href.startsWith('http')) {
                                // Convertir le chemin relatif en absolu
                                const absoluteHref = new URL(href, window.location.origin).href;
                                link.setAttribute('href', absoluteHref);
                            }
                            
                            const existing = currentHead.querySelector(`link[href="${link.getAttribute('href')}"]`);
                            if (!existing) {
                                const cloned = link.cloneNode(true);
                                currentHead.appendChild(cloned);
                            }
                        });
                        
                        // 3. Scripts (éviter les doublons)
                        scripts.forEach(script => {
                            const src = script.getAttribute('src');
                            if (src) {
                                const existing = currentHead.querySelector(`script[src="${src}"]`);
                                if (!existing) {
                                    const cloned = script.cloneNode(true);
                                    currentHead.appendChild(cloned);
                                }
                            } else if (script.textContent) {
                                // Script inline - vérifier le contenu
                                const existing = Array.from(currentHead.querySelectorAll('script')).find(s => 
                                    s.textContent === script.textContent
                                );
                                if (!existing) {
                                    const cloned = script.cloneNode(true);
                                    currentHead.appendChild(cloned);
                                }
                            }
                        });
                        
                        // 4. Autres éléments (meta, etc.)
                        others.forEach(element => {
                            // Éviter les doublons pour les meta tags spécifiques
                            if (element.tagName === 'META') {
                                const name = element.getAttribute('name');
                                const property = element.getAttribute('property');
                                if (name || property) {
                                    const selector = name ? `meta[name="${name}"]` : `meta[property="${property}"]`;
                                    const existing = currentHead.querySelector(selector);
                                    if (existing) {
                                        // Mettre à jour l'existant au lieu de créer un doublon
                                        Array.from(element.attributes).forEach(attr => {
                                            existing.setAttribute(attr.name, attr.value);
                                        });
                                        return;
                                    }
                                }
                            }
                            const cloned = element.cloneNode(true);
                            currentHead.appendChild(cloned);
                        });
                        
                        // IMPORTANT : S'assurer que les éléments cibles pour les swaps OOB existent avec les bons IDs
                        // Ces éléments sont nécessaires pour que HTMX puisse faire les swaps OOB
                        let titleEl = currentHead.querySelector('#site-title');
                        if (!titleEl) {
                            // Chercher par tag name si l'ID n'existe pas
                            titleEl = currentHead.querySelector('title');
                            if (titleEl) {
                                titleEl.id = 'site-title';
                            } else {
                                titleEl = document.createElement('title');
                                titleEl.id = 'site-title';
                                currentHead.appendChild(titleEl);
                            }
                        }
                        
                        let metaDescEl = currentHead.querySelector('#meta-desc');
                        if (!metaDescEl) {
                            // Chercher par name si l'ID n'existe pas
                            metaDescEl = currentHead.querySelector('meta[name="description"]');
                            if (metaDescEl) {
                                metaDescEl.id = 'meta-desc';
                            } else {
                                metaDescEl = document.createElement('meta');
                                metaDescEl.id = 'meta-desc';
                                metaDescEl.setAttribute('name', 'description');
                                currentHead.appendChild(metaDescEl);
                            }
                        }
                        
                        let metaKeywordsEl = currentHead.querySelector('#meta-keywords');
                        if (!metaKeywordsEl) {
                            // Chercher par name si l'ID n'existe pas
                            metaKeywordsEl = currentHead.querySelector('meta[name="keywords"]');
                            if (metaKeywordsEl) {
                                metaKeywordsEl.id = 'meta-keywords';
                            } else {
                                metaKeywordsEl = document.createElement('meta');
                                metaKeywordsEl.id = 'meta-keywords';
                                metaKeywordsEl.setAttribute('name', 'keywords');
                                currentHead.appendChild(metaKeywordsEl);
                            }
                        }
                        
                        // Mettre à jour le titre si disponible
                        if (metadata && metadata.title) {
                            titleEl.textContent = metadata.title + ' - Preview';
                        }
                        
                        // Mettre à jour les meta tags si disponibles
                        if (metadata && metadata.metaDesc) {
                            metaDescEl.setAttribute('content', metadata.metaDesc);
                        }
                        if (metadata && metadata.metaKeywords) {
                            metaKeywordsEl.setAttribute('content', metadata.metaKeywords);
                        }
                    }
                    
                    // Fonction pour corriger les chemins relatifs dans les attributs
                    const fixRelativePaths = (element) => {
                        // Corriger les images
                        const images = element.querySelectorAll('img[src]');
                        images.forEach(img => {
                            const src = img.getAttribute('src');
                            if (src && src.startsWith('/') && !src.startsWith('//') && !src.startsWith('http')) {
                                img.setAttribute('src', new URL(src, window.location.origin).href);
                            }
                        });
                        
                        // Corriger les autres ressources (CSS, JS, etc. dans les attributs style)
                        const elementsWithStyle = element.querySelectorAll('[style]');
                        elementsWithStyle.forEach(el => {
                            const style = el.getAttribute('style');
                            if (style && style.includes('url(')) {
                                // Corriger les URLs dans les styles inline
                                const correctedStyle = style.replace(/url\(['"]?(\/[^'")]+)['"]?\)/g, (match, path) => {
                                    if (!path.startsWith('//') && !path.startsWith('http')) {
                                        return `url('${new URL(path, window.location.origin).href}')`;
                                    }
                                    return match;
                                });
                                el.setAttribute('style', correctedStyle);
                            }
                        });
                    };
                    
                    // Remplacer le body
                    if (doc.body) {
                        document.body.innerHTML = doc.body.innerHTML;
                        fixRelativePaths(document.body);
                    } else {
                        // Fallback: injecter directement dans le body si pas de structure HTML complète
                    document.body.innerHTML = html;
                        fixRelativePaths(document.body);
                    }
                    
                    // Forcer le rechargement des styles après injection
                    const styleSheets = document.styleSheets;
                    for (let i = 0; i < styleSheets.length; i++) {
                        try {
                            styleSheets[i].cssRules; // Force le chargement
                        } catch (e) {
                            // Ignorer les erreurs CORS
                        }
                    }
                    
                    // Réinitialiser Tailwind si présent
                    if (typeof tailwind !== 'undefined' && tailwind.refresh) {
                        tailwind.refresh();
                    }
                    
                    // Modifier tous les liens HTMX pour qu'ils pointent vers preview.html avec le slug
                    const allLinks = document.querySelectorAll('[hx-get], [hx-post], [hx-put], [hx-delete]');
                    allLinks.forEach(link => {
                        const hxGet = link.getAttribute('hx-get');
                        const hxPost = link.getAttribute('hx-post');
                        const hxPut = link.getAttribute('hx-put');
                        const hxDelete = link.getAttribute('hx-delete');
                        
                        // Modifier hx-get
                        if (hxGet && !hxGet.startsWith('http') && !hxGet.startsWith('/api/') && !hxGet.startsWith('/admin') && !hxGet.startsWith('/preview')) {
                            const newUrl = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(hxGet)}`;
                            link.setAttribute('hx-get', newUrl);
                        }
                        
                        // Modifier hx-post
                        if (hxPost && !hxPost.startsWith('http') && !hxPost.startsWith('/api/') && !hxPost.startsWith('/admin') && !hxPost.startsWith('/preview')) {
                            const newUrl = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(hxPost)}`;
                            link.setAttribute('hx-post', newUrl);
                        }
                        
                        // Modifier hx-put
                        if (hxPut && !hxPut.startsWith('http') && !hxPut.startsWith('/api/') && !hxPut.startsWith('/admin') && !hxPut.startsWith('/preview')) {
                            const newUrl = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(hxPut)}`;
                            link.setAttribute('hx-put', newUrl);
                        }
                        
                        // Modifier hx-delete
                        if (hxDelete && !hxDelete.startsWith('http') && !hxDelete.startsWith('/api/') && !hxDelete.startsWith('/admin') && !hxDelete.startsWith('/preview')) {
                            const newUrl = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(hxDelete)}`;
                            link.setAttribute('hx-delete', newUrl);
                        }
                    });
                    
                    // Modifier aussi les attributs href pour la navigation normale
                    const hrefLinks = document.querySelectorAll('a[href]');
                    hrefLinks.forEach(link => {
                        const href = link.getAttribute('href');
                        if (href && !href.startsWith('http') && !href.startsWith('#') && !href.startsWith('/api/') && !href.startsWith('/admin') && !href.startsWith('mailto:') && !href.startsWith('tel:') && !href.startsWith('/preview')) {
                            const newHref = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(href)}`;
                            link.setAttribute('href', newHref);
                        }
                    });
                    
                    // Intercepter les requêtes HTMX pour rediriger vers preview
                    document.body.addEventListener('htmx:configRequest', (event) => {
                        const requestPath = event.detail.path;
                        
                        // Si ce n'est pas déjà une requête vers preview et pas une API/admin
                        if (!requestPath.startsWith('/preview') && 
                            !requestPath.startsWith('/api/') && 
                            !requestPath.startsWith('/admin')) {
                            
                            // Rediriger vers preview avec le slug et le path
                            const newPath = `/preview?slug=${encodeURIComponent(currentSlug)}&path=${encodeURIComponent(requestPath)}`;
                            event.detail.path = newPath;
                        }
                    });
                    
                    // Initialiser HTMX après l'injection
                    if (typeof htmx !== 'undefined') {
                        htmx.process(document.body);
                        
                        // IMPORTANT : Gérer les swaps OOB manuellement si nécessaire
                        // HTMX devrait normalement les gérer automatiquement, mais on s'assure qu'ils sont bien traités
                        document.body.addEventListener('htmx:afterSwap', (event) => {
                            // Vérifier si des éléments OOB sont présents dans le body (ils ne devraient pas y être)
                            const oobElements = document.body.querySelectorAll('[hx-swap-oob="true"]');
                            if (oobElements.length > 0) {
                                console.log('[Preview] Moving OOB elements to head:', oobElements.length);
                                oobElements.forEach(oobEl => {
                                    const id = oobEl.id;
                                    if (id) {
                                        // Trouver l'élément cible dans le head
                                        const target = document.head.querySelector(`#${id}`);
                                        if (target) {
                                            // Mettre à jour le contenu de l'élément cible
                                            if (oobEl.tagName === 'TITLE') {
                                                target.textContent = oobEl.textContent;
                                            } else if (oobEl.tagName === 'META') {
                                                // Copier tous les attributs
                                                Array.from(oobEl.attributes).forEach(attr => {
                                                    if (attr.name !== 'hx-swap-oob' && attr.name !== 'id') {
                                                        target.setAttribute(attr.name, attr.value);
                                                    }
                                                });
                                                // Pour les meta, copier aussi le content
                                                if (oobEl.getAttribute('content')) {
                                                    target.setAttribute('content', oobEl.getAttribute('content'));
                                                }
                                            }
                                        } else {
                                            // Si l'élément cible n'existe pas, le créer dans le head
                                            const cloned = oobEl.cloneNode(true);
                                            cloned.removeAttribute('hx-swap-oob');
                                            document.head.appendChild(cloned);
                                        }
                                        // Supprimer l'élément OOB du body
                                        oobEl.remove();
                                    }
                                });
                            }
                        });
                    }
                } catch (e) {
                    document.body.innerHTML = `
                        <div style="padding: 2rem;">
                            <h1>Erreur</h1>
                            <p>${e.message}</p>
                        </div>
                    `;
                }
            } else {
                // Afficher un message si aucun template
                document.body.innerHTML = `
                    <div style="padding: 2rem; text-align: center;">
                        <h1>Aucun template trouvé</h1>
                        <p>Ouvrez l'IDE et sauvegardez un template pour le prévisualiser.</p>
                        <p>Slug recherché: <code>${currentSlug}</code></p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>

