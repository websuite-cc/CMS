<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Éditeur Visuel - StackPages CMS</title>
    <link rel="icon" type="image/x-icon" href="https://stackpages.net/img/logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Toolbar transition */
        #editor-toolbar {
            transition: opacity 0.2s, transform 0.2s;
        }
    </style>
</head>

<body class="bg-slate-100 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center z-20 shadow-sm gap-4">
        <div class="flex items-center gap-4 shrink-0">
            <a href="/admin/dashboard.html" class="text-slate-400 hover:text-orange-500 transition"
                title="Retour au dashboard">
                <i class="fas fa-arrow-left text-xl"></i>
            </a>
            <h1 class="text-lg font-bold text-slate-800 flex items-center gap-2">
                <i class="fas fa-paint-brush text-orange-500"></i>
                Éditeur Visuel
            </h1>
            <div class="h-6 w-px bg-slate-200 mx-2"></div>
            <select id="page-selector"
                class="bg-slate-50 border border-slate-300 text-slate-700 text-sm rounded-lg focus:ring-orange-500 focus:border-orange-500 block p-2 min-w-[200px]">
                <option value="">Sélectionner une page...</option>
                <!-- Populated by JS -->
            </select>
        </div>



        <div class="flex items-center gap-3 shrink-0">
            <div id="save-status" class="text-sm text-slate-500 mr-2"></div>

            <!-- Switch Mode Button -->
            <button onclick="switchToIDE()"
                class="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-lg text-sm font-medium transition flex items-center gap-2 border border-slate-300 mr-2">
                <i class="fas fa-code"></i>
                <span>Passer à l'IDE</span>
            </button>

            <button onclick="toggleEditMode()" id="edit-mode-btn"
                class="px-3 py-2 bg-white border border-slate-300 text-slate-700 hover:bg-slate-50 rounded-lg font-medium transition flex items-center gap-2 text-sm">
                <i class="fas fa-edit"></i> <span id="edit-mode-text">Mode Édition</span>
            </button>
            <button onclick="saveCurrentPage()"
                class="px-4 py-2 bg-slate-800 hover:bg-slate-900 text-white rounded-lg font-medium transition shadow-sm hover:shadow flex items-center gap-2 text-sm">
                <i class="fas fa-save"></i> Enregistrer
            </button>
            <button onclick="publishCurrentPage()"
                class="px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg font-medium transition shadow-sm hover:shadow flex items-center gap-2 text-sm">
                <i class="fas fa-globe"></i> Publier
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 relative flex justify-center bg-slate-100 p-4 overflow-hidden">

        <!-- Device Frame (Enlarged) -->
        <div id="device-frame"
            class="bg-white shadow-2xl rounded-lg overflow-hidden w-full max-w-[95%] h-full border border-slate-200 relative transition-all duration-300">
            <!-- Iframe for Page Content -->
            <iframe id="editor-frame" class="w-full h-full bg-white" sandbox="allow-same-origin allow-scripts"></iframe>

            <!-- Empty State -->
            <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-50 z-10">
                <div class="w-20 h-20 bg-slate-200 rounded-full flex items-center justify-center text-slate-400 mb-4">
                    <i class="fas fa-mouse-pointer text-3xl"></i>
                </div>
                <h3 class="text-xl font-semibold text-slate-700 mb-2">Sélectionnez une page</h3>
                <p class="text-slate-500">Choisissez une page dans le menu déroulant pour commencer l'édition visuelle.
                </p>
            </div>
        </div>

        <!-- Image Bank Modal -->
        <div id="image-bank-modal"
            class="fixed inset-0 z-[60] hidden bg-black/50 backdrop-blur-sm flex items-center justify-center p-4">
            <div
                class="bg-white rounded-xl shadow-2xl w-full max-w-4xl h-[80vh] flex flex-col overflow-hidden border border-slate-200">
                <!-- Modal Header -->
                <div class="px-6 py-4 border-b border-slate-100 flex justify-between items-center bg-slate-50">
                    <h3 class="font-bold text-lg text-slate-800 flex items-center gap-2">
                        <i class="fas fa-camera text-orange-500"></i>
                        Banque d'Images (Pexels)
                    </h3>
                    <div class="flex items-center gap-2">
                        <button onclick="toggleImageSettings()"
                            class="text-slate-400 hover:text-slate-600 transition p-2 rounded-full hover:bg-slate-200"
                            title="Configuration API">
                            <i class="fas fa-cog"></i>
                        </button>
                        <button onclick="closeImageBank()"
                            class="text-slate-400 hover:text-slate-600 transition p-2 rounded-full hover:bg-slate-200">
                            <i class="fas fa-times text-xl"></i>
                        </button>
                    </div>
                </div>

                <!-- Tabs -->
                <div class="flex px-6 border-b border-slate-100 bg-slate-50 gap-6">
                    <button onclick="switchImageTab('pexels')" id="tab-pexels"
                        class="py-3 text-sm font-medium text-orange-600 border-b-2 border-orange-600 transition">
                        Photos Gratuites (Pexels)
                    </button>
                    <button onclick="switchImageTab('upload')" id="tab-upload"
                        class="py-3 text-sm font-medium text-slate-500 hover:text-slate-700 border-b-2 border-transparent transition">
                        Upload GitHub
                    </button>
                </div>

                <!-- Settings Panel (Hidden by default) -->
                <div id="image-settings-panel" class="hidden bg-slate-100 p-4 border-b border-slate-200">
                    <label class="block text-sm font-medium text-slate-700 mb-2">Clé API Pexels</label>
                    <div class="flex gap-2">
                        <input type="password" id="pexels-api-key" placeholder="Entrez votre clé API Pexels..."
                            class="flex-1 px-3 py-2 border border-slate-300 rounded-lg focus:ring-orange-500 focus:border-orange-500">
                        <button onclick="savePexelsKey()"
                            class="px-4 py-2 bg-slate-800 text-white rounded-lg hover:bg-slate-700 transition">
                            Sauvegarder
                        </button>
                    </div>
                    <p class="text-xs text-slate-500 mt-2">
                        Vous pouvez obtenir une clé gratuite sur <a href="https://www.pexels.com/api/" target="_blank"
                            class="text-blue-500 hover:underline">Pexels API</a>.
                    </p>
                </div>

                <!-- Pexels Panel -->
                <div id="panel-pexels" class="flex flex-col flex-1 overflow-hidden">
                    <!-- Search Bar -->
                    <div class="p-4 border-b border-slate-100 flex gap-2 bg-white">
                        <div class="relative flex-1">
                            <i class="fas fa-search absolute left-3 top-3 text-slate-400"></i>
                            <input type="text" id="image-search-input"
                                placeholder="Rechercher des photos (ex: nature, bureau, tech...)"
                                class="w-full pl-10 pr-4 py-2.5 bg-slate-50 border border-slate-200 rounded-lg focus:ring-orange-500 focus:border-orange-500 transition"
                                onkeypress="if(event.key === 'Enter') searchImages()">
                        </div>
                        <button onclick="searchImages()"
                            class="px-6 py-2.5 bg-orange-500 hover:bg-orange-600 text-white rounded-lg font-medium transition shadow-sm">
                            Rechercher
                        </button>
                    </div>

                    <!-- Results Grid -->
                    <div id="image-results"
                        class="flex-1 overflow-y-auto p-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 bg-slate-50">
                        <!-- Empty State -->
                        <div class="col-span-full flex flex-col items-center justify-center text-slate-400 py-20">
                            <i class="fas fa-images text-4xl mb-4 opacity-50"></i>
                            <p>Recherchez des images pour commencer</p>
                        </div>
                    </div>

                    <!-- Loading State (Hidden) -->
                    <div id="image-loading" class="hidden col-span-full flex justify-center py-10">
                        <i class="fas fa-circle-notch fa-spin text-3xl text-orange-500"></i>
                    </div>
                </div>

                <!-- Upload Panel -->
                <div id="panel-upload"
                    class="hidden flex-col flex-1 overflow-hidden p-8 items-center justify-center bg-slate-50">
                    <div class="w-full max-w-md bg-white border-2 border-dashed border-slate-300 rounded-xl p-8 text-center hover:border-orange-400 transition cursor-pointer group"
                        onclick="document.getElementById('file-upload').click()"
                        ondragover="event.preventDefault(); this.classList.add('border-orange-400', 'bg-orange-50')"
                        ondragleave="this.classList.remove('border-orange-400', 'bg-orange-50')"
                        ondrop="handleDrop(event)">

                        <div
                            class="w-16 h-16 bg-slate-100 rounded-full flex items-center justify-center mx-auto mb-4 group-hover:bg-orange-100 transition">
                            <i
                                class="fas fa-cloud-upload-alt text-3xl text-slate-400 group-hover:text-orange-500 transition"></i>
                        </div>
                        <h3 class="text-lg font-medium text-slate-700 mb-2">Glissez une image ici</h3>
                        <p class="text-slate-500 text-sm mb-6">ou cliquez pour sélectionner</p>

                        <input type="file" id="file-upload" class="hidden" accept="image/*"
                            onchange="handleFileSelect(event)">

                        <button
                            class="px-4 py-2 bg-white border border-slate-300 rounded-lg text-slate-700 hover:bg-slate-50 font-medium text-sm shadow-sm">
                            Sélectionner un fichier
                        </button>
                    </div>

                    <div id="upload-progress" class="hidden w-full max-w-md mt-6">
                        <div class="flex justify-between text-xs text-slate-500 mb-1">
                            <span>Upload en cours...</span>
                            <span id="upload-percent">0%</span>
                        </div>
                        <div class="w-full bg-slate-200 rounded-full h-2">
                            <div id="upload-bar" class="bg-orange-500 h-2 rounded-full transition-all duration-300"
                                style="width: 0%"></div>
                        </div>
                    </div>

                    <div class="mt-8 text-center">
                        <p class="text-xs text-slate-400">
                            Les images seront uploadées dans le dossier <code>content/images/</code> de votre dépôt
                            GitHub.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toolbar (Moved to bottom) -->
        <div id="editor-toolbar"
            class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-4 py-2 rounded-full shadow-xl flex items-center gap-2 transition-all duration-200 z-50 border border-slate-700 opacity-90 hover:opacity-100">

            <!-- History -->
            <div class="flex items-center gap-0.5">
                <button onclick="customUndo()" class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Annuler">
                    <i class="fas fa-undo text-sm"></i>
                </button>
                <button onclick="customRedo()" class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Rétablir">
                    <i class="fas fa-redo text-sm"></i>
                </button>
            </div>

            <div class="w-px h-5 bg-white/20 mx-1"></div>

            <!-- Formatting -->
            <div class="flex items-center gap-0.5">
                <button onclick="execCmd('bold')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Gras">
                    <i class="fas fa-bold text-sm"></i>
                </button>
                <button onclick="execCmd('italic')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Italique">
                    <i class="fas fa-italic text-sm"></i>
                </button>
                <button onclick="execCmd('underline')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Souligné">
                    <i class="fas fa-underline text-sm"></i>
                </button>
                <button onclick="promptLink()" class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Lien">
                    <i class="fas fa-link text-sm"></i>
                </button>
            </div>

            <div class="w-px h-5 bg-white/20 mx-1"></div>

            <!-- Headings -->
            <div class="flex items-center gap-0.5">
                <button onclick="execCmd('h2')"
                    class="p-1.5 hover:text-orange-400 transition font-bold text-sm rounded hover:bg-white/10"
                    title="Titre 2">H2</button>
                <button onclick="execCmd('h3')"
                    class="p-1.5 hover:text-orange-400 transition font-bold text-sm rounded hover:bg-white/10"
                    title="Titre 3">H3</button>
                <button onclick="execCmd('p')" class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Paragraphe">
                    <i class="fas fa-paragraph text-sm"></i>
                </button>
            </div>

            <div class="w-px h-5 bg-white/20 mx-1"></div>

            <!-- Alignment & Lists -->
            <div class="flex items-center gap-0.5">
                <button onclick="execCmd('justifyLeft')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Aligner à gauche">
                    <i class="fas fa-align-left text-sm"></i>
                </button>
                <button onclick="execCmd('justifyCenter')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Centrer">
                    <i class="fas fa-align-center text-sm"></i>
                </button>
                <button onclick="execCmd('insertUnorderedList')"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Liste à puces">
                    <i class="fas fa-list-ul text-sm"></i>
                </button>
            </div>

            <div class="w-px h-5 bg-white/20 mx-1"></div>

            <!-- Inserts -->
            <div class="flex items-center gap-0.5">
                <div class="relative group">
                    <button onclick="document.getElementById('color-picker').click()"
                        class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10 flex items-center gap-1"
                        title="Couleur du texte">
                        <i class="fas fa-palette text-sm"></i>
                    </button>
                    <input type="color" id="color-picker" class="absolute opacity-0 w-0 h-0"
                        onchange="execCmd('foreColor', this.value)" value="#000000">
                </div>
                <button onclick="promptImage()" class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Image">
                    <i class="fas fa-image text-sm"></i>
                </button>
                <button onclick="openImageBank()"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10" title="Banque d'images">
                    <i class="fas fa-cloud-download-alt text-sm"></i>
                </button>
                <button onclick="duplicateElement()"
                    class="p-1.5 hover:text-orange-400 transition rounded hover:bg-white/10"
                    title="Dupliquer l'élément">
                    <i class="fas fa-copy text-sm"></i>
                </button>
            </div>
        </div>

        <script>
            let currentPageSlug = null;
            let isEditMode = false; // Initialize isEditMode
            let pexelsApiKey = localStorage.getItem('stackpages_pexels_key') || '';
            let currentImageSelection = null; // To store the image element being edited

            // History management for undo/redo
            let historyStack = [];
            let historyIndex = -1;
            let isRestoringState = false; // Flag to prevent saving during restore
            const MAX_HISTORY = 50; // Limit history to prevent memory issues

            // --- Initialization ---
            document.addEventListener('DOMContentLoaded', () => {
                loadPagesList();

                // Handle page selection
                document.getElementById('page-selector').addEventListener('change', (e) => {
                    const slug = e.target.value;
                    if (slug) {
                        loadPage(slug);
                    } else {
                        showEmptyState();
                    }
                });
            });

            // --- Data Loading ---
            function loadPagesList() {
                try {
                    const stored = localStorage.getItem('stackpages_custom_pages');
                    const pages = stored ? JSON.parse(stored) : [];
                    const selector = document.getElementById('page-selector');

                    // Clear existing options except first
                    while (selector.options.length > 1) {
                        selector.remove(1);
                    }

                    pages.forEach(page => {
                        const option = document.createElement('option');
                        option.value = page.slug;
                        option.textContent = page.title;
                        selector.appendChild(option);
                    });

                    // Check URL param
                    const urlParams = new URLSearchParams(window.location.search);
                    const pageParam = urlParams.get('page');
                    if (pageParam) {
                        selector.value = pageParam;
                        loadPage(pageParam);
                    }

                } catch (e) {
                    console.error("Error loading pages:", e);
                }
            }

            function loadPage(slug) {
                currentPageSlug = slug;
                const stored = localStorage.getItem('stackpages_custom_pages');
                const pages = stored ? JSON.parse(stored) : [];
                const page = pages.find(p => p.slug === slug);

                if (!page) {
                    alert("Page non trouvée");
                    return;
                }

                // Hide empty state
                document.getElementById('empty-state').classList.add('hidden');

                // Load content into iframe
                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;

                // Prepare HTML with editable styles
                // We inject a small script and style to help with editing
                const editableStyles = `
                <style id="editor-styles">
                    .editable-hover { outline: 2px dashed #f97316; cursor: text; }
                    .editable-active { outline: 2px solid #f97316; }
                    [contenteditable]:empty:before { content: 'Ecrivez ici...'; color: #94a3b8; }
                    /* DRAG & DROP DISABLED
                    .draggable-element { cursor: move; position: relative; }
                    .draggable-element:hover::before { 
                        content: '⋮⋮'; 
                        position: absolute; 
                        left: -20px; 
                        top: 50%; 
                        transform: translateY(-50%);
                        color: #f97316; 
                        font-size: 18px; 
                        opacity: 0.5;
                    }
                    .drag-over { border-top: 3px solid #f97316 !important; }
                    .dragging { opacity: 0.5; }
                    */
                </style>
            `;

                doc.open();
                doc.write(page.htmlContent + editableStyles);
                doc.close();

                // Enable editing by default
                setTimeout(() => {
                    enableVisualEditing(true);
                    // Initialize history after page load
                    initializeHistory();
                }, 500);
            }

            function showEmptyState() {
                document.getElementById('empty-state').classList.remove('hidden');
                currentPageSlug = null;
            }

            // --- Editing Logic ---
            function toggleEditMode() {
                isEditMode = !isEditMode;
                enableVisualEditing(isEditMode);

                const btn = document.getElementById('edit-mode-btn');
                const text = document.getElementById('edit-mode-text');

                if (isEditMode) {
                    btn.classList.add('bg-orange-50', 'text-orange-600', 'border-orange-200');
                    text.textContent = "Mode Édition Actif";
                } else {
                    btn.classList.remove('bg-orange-50', 'text-orange-600', 'border-orange-200');
                    text.textContent = "Mode Édition";
                }
            }

            function enableVisualEditing(enable) {
                isEditMode = enable;
                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;
                const toolbar = document.getElementById('editor-toolbar');

                // Select editable elements
                const selector = 'h1, h2, h3, h4, h5, h6, p, span, div, li, a, blockquote';
                const elements = doc.querySelectorAll(selector);

                // DRAG & DROP DISABLED
                // const draggableSelector = 'p, h1, h2, h3, h4, h5, h6, div, section, article, header, footer, aside, blockquote, ul, ol';
                // const draggableElements = doc.querySelectorAll(draggableSelector);

                if (enable) {
                    // Show toolbar
                    // toolbar.classList.remove('opacity-0', 'pointer-events-none'); // Always visible now

                    elements.forEach(el => {
                        // Only make leaf nodes or specific blocks editable to avoid messing up layout structure too much
                        // For now, let's try making everything that looks like text editable
                        if (el.children.length === 0 || el.tagName === 'P' || el.tagName === 'DIV') {
                            el.setAttribute('contenteditable', 'true');

                            // Add listeners for hover effects
                            el.addEventListener('focus', () => {
                                el.classList.add('editable-active');
                                // Update toolbar position?
                            });
                            el.addEventListener('blur', () => {
                                el.classList.remove('editable-active');
                            });
                            el.addEventListener('mouseover', () => {
                                if (document.activeElement !== el) el.classList.add('editable-hover');
                            });
                            el.addEventListener('mouseout', () => {
                                el.classList.remove('editable-hover');
                            });
                        }
                    });

                    // DRAG & DROP DISABLED
                    /*
                    // Enable drag & drop for block elements
                    draggableElements.forEach(el => {
                        // Skip if element is inside another draggable element (avoid nested drag)
                        let parent = el.parentElement;
                        let hasNestedDraggable = false;
                        while (parent && parent.tagName !== 'BODY') {
                            if (parent.matches(draggableSelector) && parent.draggable) {
                                hasNestedDraggable = true;
                                break;
                            }
                            parent = parent.parentElement;
                        }

                        if (!hasNestedDraggable && el.tagName !== 'BODY') {
                            el.draggable = true;
                            el.classList.add('draggable-element');

                            // Drag start
                            el.addEventListener('dragstart', function (e) {
                                this.classList.add('dragging');
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/html', this.innerHTML);
                            });

                            // Drag end
                            el.addEventListener('dragend', function (e) {
                                this.classList.remove('dragging');
                                // Remove all drag-over classes
                                doc.querySelectorAll('.drag-over').forEach(item => {
                                    item.classList.remove('drag-over');
                                });
                            });

                            // Drag over
                            el.addEventListener('dragover', function (e) {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'move';

                                const draggingElement = doc.querySelector('.dragging');
                                if (draggingElement && draggingElement !== this) {
                                    this.classList.add('drag-over');
                                }
                            });

                            // Drag leave
                            el.addEventListener('dragleave', function (e) {
                                this.classList.remove('drag-over');
                            });

                            // Drop
                            el.addEventListener('drop', function (e) {
                                e.preventDefault();
                                e.stopPropagation();

                                this.classList.remove('drag-over');
                                const draggingElement = doc.querySelector('.dragging');

                                if (draggingElement && draggingElement !== this) {
                                    // Get the bounding rectangles
                                    const rect = this.getBoundingClientRect();
                                    const draggingRect = draggingElement.getBoundingClientRect();

                                    // Determine if we should insert before or after based on mouse position
                                    const mouseY = e.clientY;
                                    const elementMiddle = rect.top + (rect.height / 2);

                                    if (mouseY < elementMiddle) {
                                        // Insert before
                                        this.parentNode.insertBefore(draggingElement, this);
                                    } else {
                                        // Insert after
                                        this.parentNode.insertBefore(draggingElement, this.nextSibling);
                                    }
                                }
                            });
                        }
                    });
                    */

                    // Image handling
                    const images = doc.querySelectorAll('img');
                    images.forEach(img => {
                        img.style.cursor = 'pointer';
                        img.addEventListener('click', (e) => {
                            e.preventDefault();
                            currentImageSelection = img; // Store reference
                            openImageBank(); // Open bank instead of prompt
                        });
                    });

                    // Link handling
                    const links = doc.querySelectorAll('a');
                    links.forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault(); // Prevent navigation in edit mode
                        });
                    });

                } else {
                    // Cleanup
                    elements.forEach(el => {
                        el.removeAttribute('contenteditable');
                        el.classList.remove('editable-active', 'editable-hover');
                    });

                    // DRAG & DROP DISABLED
                    /*
                    // Remove drag & drop
                    draggableElements.forEach(el => {
                        el.draggable = false;
                        el.classList.remove('draggable-element', 'dragging', 'drag-over');
                    });
                    */
                }
            }

            // --- Toolbar Commands ---
            function execCmd(command, value = null) {
                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;

                if (command === 'h2' || command === 'h3' || command === 'p') {
                    doc.execCommand('formatBlock', false, command);
                } else {
                    doc.execCommand(command, false, value);
                }

                iframe.contentWindow.focus();

                // Save state after command execution
                setTimeout(() => saveState(), 100);
            }

            // --- History Management ---
            function saveState() {
                if (isRestoringState) return; // Don't save during restore

                const iframe = document.getElementById('editor-frame');
                if (!iframe || !iframe.contentWindow) return;

                const doc = iframe.contentWindow.document;
                if (!doc || !doc.body) return;

                const currentState = doc.body.innerHTML;

                // Don't save if state hasn't changed
                if (historyIndex >= 0 && historyStack[historyIndex] === currentState) {
                    return;
                }

                // Remove any redo history
                historyStack = historyStack.slice(0, historyIndex + 1);

                // Add new state
                historyStack.push(currentState);
                historyIndex++;

                // Limit history size
                if (historyStack.length > MAX_HISTORY) {
                    historyStack.shift();
                    historyIndex--;
                }
            }

            function customUndo() {
                if (historyIndex <= 0) return; // Nothing to undo

                historyIndex--;
                restoreState(historyStack[historyIndex]);
            }

            function customRedo() {
                if (historyIndex >= historyStack.length - 1) return; // Nothing to redo

                historyIndex++;
                restoreState(historyStack[historyIndex]);
            }

            function restoreState(html) {
                isRestoringState = true;

                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;

                doc.body.innerHTML = html;

                // Re-enable editing after restore
                if (isEditMode) {
                    setTimeout(() => {
                        enableVisualEditing(true);
                        isRestoringState = false;
                    }, 50);
                } else {
                    isRestoringState = false;
                }
            }

            function initializeHistory() {
                const iframe = document.getElementById('editor-frame');
                if (!iframe || !iframe.contentWindow) return;

                const doc = iframe.contentWindow.document;
                if (!doc || !doc.body) return;

                // Save initial state
                historyStack = [doc.body.innerHTML];
                historyIndex = 0;

                // Listen to input events for text editing
                doc.addEventListener('input', () => {
                    if (!isRestoringState) {
                        // Debounce state saving
                        clearTimeout(window.saveStateTimeout);
                        window.saveStateTimeout = setTimeout(() => saveState(), 500);
                    }
                });
            }

            function promptLink() {
                const url = prompt("Entrez l'URL du lien:");
                if (url) execCmd('createLink', url);
            }

            function promptImage() {
                // Use Image Bank instead of prompt
                currentImageSelection = null; // Ensure we are inserting new
                openImageBank();
            }

            function duplicateElement() {
                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;
                const selection = doc.getSelection();

                if (!selection || !selection.anchorNode) {
                    alert("Veuillez sélectionner un élément à dupliquer");
                    return;
                }

                // Find the closest block-level element to duplicate
                let elementToDuplicate = selection.anchorNode;

                // If it's a text node, get its parent element
                if (elementToDuplicate.nodeType === Node.TEXT_NODE) {
                    elementToDuplicate = elementToDuplicate.parentElement;
                }

                // Try to find a meaningful block element (not body or html)
                while (elementToDuplicate &&
                    elementToDuplicate.tagName !== 'P' &&
                    elementToDuplicate.tagName !== 'DIV' &&
                    elementToDuplicate.tagName !== 'H1' &&
                    elementToDuplicate.tagName !== 'H2' &&
                    elementToDuplicate.tagName !== 'H3' &&
                    elementToDuplicate.tagName !== 'H4' &&
                    elementToDuplicate.tagName !== 'H5' &&
                    elementToDuplicate.tagName !== 'H6' &&
                    elementToDuplicate.tagName !== 'LI' &&
                    elementToDuplicate.tagName !== 'BLOCKQUOTE' &&
                    elementToDuplicate.tagName !== 'IMG' &&
                    elementToDuplicate.tagName !== 'SECTION' &&
                    elementToDuplicate.tagName !== 'ARTICLE' &&
                    elementToDuplicate.tagName !== 'HEADER' &&
                    elementToDuplicate.tagName !== 'FOOTER' &&
                    elementToDuplicate.tagName !== 'ASIDE' &&
                    elementToDuplicate.tagName !== 'UL' &&
                    elementToDuplicate.tagName !== 'OL' &&
                    elementToDuplicate.tagName !== 'BODY') {
                    elementToDuplicate = elementToDuplicate.parentElement;
                }

                // Don't duplicate body or html
                if (!elementToDuplicate || elementToDuplicate.tagName === 'BODY' || elementToDuplicate.tagName === 'HTML') {
                    alert("Impossible de dupliquer cet élément");
                    return;
                }

                // Clone the element
                const clonedElement = elementToDuplicate.cloneNode(true);

                // Insert the clone after the original
                elementToDuplicate.parentNode.insertBefore(clonedElement, elementToDuplicate.nextSibling);

                // Re-enable editing on the new element if in edit mode
                if (isEditMode) {
                    const selector = 'h1, h2, h3, h4, h5, h6, p, span, div, li, a, blockquote';
                    const elements = clonedElement.querySelectorAll(selector);

                    elements.forEach(el => {
                        if (el.children.length === 0 || el.tagName === 'P' || el.tagName === 'DIV') {
                            el.setAttribute('contenteditable', 'true');

                            el.addEventListener('focus', () => {
                                el.classList.add('editable-active');
                            });
                            el.addEventListener('blur', () => {
                                el.classList.remove('editable-active');
                            });
                            el.addEventListener('mouseover', () => {
                                if (doc.activeElement !== el) el.classList.add('editable-hover');
                            });
                            el.addEventListener('mouseout', () => {
                                el.classList.remove('editable-hover');
                            });
                        }
                    });

                    // Handle images in the cloned element
                    const images = clonedElement.querySelectorAll('img');
                    images.forEach(img => {
                        img.style.cursor = 'pointer';
                        img.addEventListener('click', (e) => {
                            e.preventDefault();
                            currentImageSelection = img;
                            openImageBank();
                        });
                    });

                    // Handle links in the cloned element
                    const links = clonedElement.querySelectorAll('a');
                    links.forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                        });
                    });

                    // If the cloned element itself is editable
                    if (clonedElement.matches(selector)) {
                        if (clonedElement.children.length === 0 || clonedElement.tagName === 'P' || clonedElement.tagName === 'DIV') {
                            clonedElement.setAttribute('contenteditable', 'true');

                            clonedElement.addEventListener('focus', () => {
                                clonedElement.classList.add('editable-active');
                            });
                            clonedElement.addEventListener('blur', () => {
                                clonedElement.classList.remove('editable-active');
                            });
                            clonedElement.addEventListener('mouseover', () => {
                                if (doc.activeElement !== clonedElement) clonedElement.classList.add('editable-hover');
                            });
                            clonedElement.addEventListener('mouseout', () => {
                                clonedElement.classList.remove('editable-hover');
                            });
                        }
                    }
                }

                // Scroll to the duplicated element and highlight it briefly
                clonedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                clonedElement.style.outline = '3px solid #f97316';
                setTimeout(() => {
                    clonedElement.style.outline = '';
                }, 1500);

                // Save state after duplication
                saveState();
            }

            // --- Saving ---
            function saveCurrentPage(shouldPublish = false) {
                if (!currentPageSlug) return;

                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;

                // Clean up before saving
                // Remove injected styles
                const style = doc.getElementById('editor-styles');
                if (style) style.remove();

                // Remove contenteditable attributes and classes
                const allElements = doc.querySelectorAll('*');
                allElements.forEach(el => {
                    el.removeAttribute('contenteditable');
                    el.classList.remove('editable-active', 'editable-hover');
                    // Remove inline styles added by us if any (cursor pointer on images)
                    if (el.tagName === 'IMG') el.style.cursor = '';
                });

                // Get HTML
                let htmlContent = doc.documentElement.outerHTML;
                // Or better, just the body content if we are managing full pages?
                // The IDE saves full HTML usually.
                // But `doc.documentElement.outerHTML` includes <html>...</html>

                // Note: The IDE `previewPageNewTab` wraps content in a template.
                // If the saved content is just the body or a fragment, we should be careful.
                // Let's check what `IDE.html` saves. It saves `monacoEditor.getValue()`.
                // If the user pasted a full HTML page, it saves that.
                // So we should save the full HTML.

                // Re-inject the style for continuing editing if we stay on page?
                // Actually, `loadPage` re-injects it.
                // But if we save, we want to save the CLEAN version.

                // Update LocalStorage
                try {
                    const stored = localStorage.getItem('stackpages_custom_pages');
                    const pages = stored ? JSON.parse(stored) : [];
                    const pageIndex = pages.findIndex(p => p.slug === currentPageSlug);

                    if (pageIndex !== -1) {
                        pages[pageIndex].htmlContent = htmlContent;
                        pages[pageIndex].updatedAt = new Date().toISOString();

                        if (shouldPublish) {
                            pages[pageIndex].status = 'published';
                        }

                        localStorage.setItem('stackpages_custom_pages', JSON.stringify(pages));

                        // Feedback
                        const status = document.getElementById('save-status');
                        status.textContent = shouldPublish ? "Publié !" : "Sauvegardé !";
                        status.classList.add('text-green-600');
                        setTimeout(() => {
                            status.textContent = "";
                            status.classList.remove('text-green-600');
                        }, 2000);

                        // Restore edit mode
                        if (isEditMode) {
                            // We need to re-inject styles because we removed them
                            const editableStyles = `
                            <style id="editor-styles">
                                .editable-hover { outline: 2px dashed #f97316; cursor: text; }
                                .editable-active { outline: 2px solid #f97316; }
                                [contenteditable]:empty:before { content: 'Ecrivez ici...'; color: #94a3b8; }
                            </style>
                        `;
                            doc.head.insertAdjacentHTML('beforeend', editableStyles);
                            enableVisualEditing(true);
                        }
                    }
                } catch (e) {
                    console.error("Save error:", e);
                    alert("Erreur lors de la sauvegarde");
                }
            }

            async function publishCurrentPage() {
                if (!confirm("Voulez-vous publier cette page sur GitHub ?")) return;

                // 1. Save locally first
                saveCurrentPage(true);

                // 2. Get GitHub Config
                const ghConfig = JSON.parse(localStorage.getItem('stackpages_github_config') || '{}');
                if (!ghConfig.owner || !ghConfig.repo || !ghConfig.token) {
                    alert("Configuration GitHub manquante. Veuillez la configurer dans le tableau de bord.");
                    return;
                }

                // 3. Prepare Content
                const iframe = document.getElementById('editor-frame');
                const doc = iframe.contentWindow.document;

                // Clean content (same as save)
                const style = doc.getElementById('editor-styles');
                if (style) style.remove();
                const allElements = doc.querySelectorAll('*');
                allElements.forEach(el => {
                    el.removeAttribute('contenteditable');
                    el.classList.remove('editable-active', 'editable-hover');
                    if (el.tagName === 'IMG') el.style.cursor = '';
                });
                let htmlContent = doc.documentElement.outerHTML;

                // Restore styles for editing
                if (isEditMode) {
                    const editableStyles = `
                    <style id="editor-styles">
                        .editable-hover { outline: 2px dashed #f97316; cursor: text; }
                        .editable-active { outline: 2px solid #f97316; }
                        [contenteditable]:empty:before { content: 'Ecrivez ici...'; color: #94a3b8; }
                    </style>
                `;
                    doc.head.insertAdjacentHTML('beforeend', editableStyles);
                    enableVisualEditing(true);
                }

                // 4. Push to GitHub
                const path = `content/pages/${currentPageSlug}.html`;
                const contentBase64 = btoa(unescape(encodeURIComponent(htmlContent))); // Handle UTF-8
                const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/${path}`;

                const status = document.getElementById('save-status');
                status.textContent = "Publication sur GitHub...";
                status.classList.add('text-blue-600');

                try {
                    // Check if file exists to get SHA (needed for update)
                    let sha = null;
                    const checkRes = await fetch(url, {
                        headers: {
                            'Authorization': `token ${ghConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (checkRes.ok) {
                        const data = await checkRes.json();
                        sha = data.sha;
                    }

                    // PUT request
                    const body = {
                        message: `Publish page: ${currentPageSlug}`,
                        content: contentBase64,
                        branch: 'main' // or master
                    };
                    if (sha) body.sha = sha;

                    const putRes = await fetch(url, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${ghConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    if (putRes.ok) {
                        status.textContent = "Publié sur GitHub !";
                        status.classList.remove('text-blue-600');
                        status.classList.add('text-green-600');
                        setTimeout(() => status.textContent = "", 3000);
                    } else {
                        const err = await putRes.json();
                        throw new Error(err.message);
                    }

                } catch (e) {
                    console.error("GitHub Error:", e);
                    status.textContent = "Erreur GitHub";
                    status.classList.remove('text-blue-600');
                    status.classList.add('text-red-600');
                    alert(`Erreur lors de la publication GitHub: ${e.message}`);
                }
            }

            function switchToIDE() {
                if (currentPageSlug) {
                    saveCurrentPage(); // Save before switching
                    window.location.href = `/admin/IDE.html?page=${currentPageSlug}`;
                } else {
                    window.location.href = '/admin/IDE.html';
                }
            }

            // --- Image Bank Logic ---
            function openImageBank() {
                document.getElementById('image-bank-modal').classList.remove('hidden');
                const key = localStorage.getItem('stackpages_pexels_key');
                // If opening for replacement, maybe we don't need to force settings if they just want to upload
                // But let's keep it simple.
                if (!key && !document.getElementById('tab-upload').classList.contains('text-orange-600')) {
                    // Only show settings if on Pexels tab and no key (optional refinement)
                }

                // If we are replacing an image, maybe switch to upload tab by default?
                // Or keep last state. Let's keep last state or default.

                document.getElementById('image-search-input').focus();
            }

            function closeImageBank() {
                document.getElementById('image-bank-modal').classList.add('hidden');
                currentImageSelection = null; // Reset selection on close to avoid stuck state
            }

            function toggleImageSettings() {
                document.getElementById('image-settings-panel').classList.toggle('hidden');
                const keyInput = document.getElementById('pexels-api-key');
                if (!document.getElementById('image-settings-panel').classList.contains('hidden')) {
                    keyInput.value = localStorage.getItem('stackpages_pexels_key') || '';
                }
            }

            function savePexelsKey() {
                const key = document.getElementById('pexels-api-key').value.trim();
                if (key) {
                    localStorage.setItem('stackpages_pexels_key', key);
                    alert("Clé API Pexels sauvegardée !");
                    toggleImageSettings();
                } else {
                    alert("Veuillez entrer une clé valide.");
                }
            }

            async function searchImages() {
                const query = document.getElementById('image-search-input').value.trim();
                const apiKey = localStorage.getItem('stackpages_pexels_key');
                const resultsContainer = document.getElementById('image-results');

                if (!query) return;
                if (!apiKey) {
                    alert("Veuillez d'abord configurer votre clé API Pexels.");
                    document.getElementById('image-settings-panel').classList.remove('hidden');
                    return;
                }

                // Show loading
                resultsContainer.innerHTML = '<div class="col-span-full flex justify-center py-20"><i class="fas fa-circle-notch fa-spin text-3xl text-orange-500"></i></div>';

                try {
                    const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=20`, {
                        headers: {
                            'Authorization': apiKey
                        }
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || "Erreur lors de la recherche");
                    }

                    if (data.photos.length === 0) {
                        resultsContainer.innerHTML = `
                        <div class="col-span-full flex flex-col items-center justify-center text-slate-400 py-20">
                            <i class="fas fa-search-minus text-4xl mb-4 opacity-50"></i>
                            <p>Aucun résultat trouvé pour "${query}"</p>
                        </div>`;
                        return;
                    }

                    resultsContainer.innerHTML = data.photos.map(img => `
                    <div class="group relative aspect-video bg-slate-200 rounded-lg overflow-hidden cursor-pointer hover:shadow-lg transition border border-slate-200"
                        onclick="selectImage('${img.src.large}', '${img.alt || ''}')">
                        <img src="${img.src.medium}" alt="${img.alt}" class="w-full h-full object-cover transition duration-500 group-hover:scale-110">
                        <div class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition flex items-center justify-center opacity-0 group-hover:opacity-100">
                            <i class="fas fa-plus text-white text-3xl drop-shadow-md"></i>
                        </div>
                        <div class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/70 to-transparent text-xs text-white opacity-0 group-hover:opacity-100 transition truncate">
                            par ${img.photographer}
                        </div>
                    </div>
                `).join('');

                } catch (e) {
                    console.error("Pexels Error:", e);
                    resultsContainer.innerHTML = `
                    <div class="col-span-full flex flex-col items-center justify-center text-red-400 py-20">
                        <i class="fas fa-exclamation-triangle text-4xl mb-4 opacity-50"></i>
                        <p>Erreur: ${e.message}</p>
                        <button onclick="toggleImageSettings()" class="mt-4 text-sm text-blue-500 hover:underline">Vérifier la clé API</button>
                    </div>`;
                }
            }

            function selectImage(url, alt) {
                if (currentImageSelection) {
                    // Replace existing image
                    currentImageSelection.src = url;
                    if (alt) currentImageSelection.alt = alt;
                    currentImageSelection = null; // Reset
                } else {
                    // Insert new image
                    execCmd('insertImage', url);
                }
                closeImageBank();

                // Save state after image insertion/replacement
                setTimeout(() => saveState(), 100);
            }

            // --- Tab Switching ---
            function switchImageTab(tab) {
                const pexelsBtn = document.getElementById('tab-pexels');
                const uploadBtn = document.getElementById('tab-upload');
                const pexelsPanel = document.getElementById('panel-pexels');
                const uploadPanel = document.getElementById('panel-upload');

                if (tab === 'pexels') {
                    pexelsBtn.classList.add('text-orange-600', 'border-orange-600');
                    pexelsBtn.classList.remove('text-slate-500', 'border-transparent');
                    uploadBtn.classList.remove('text-orange-600', 'border-orange-600');
                    uploadBtn.classList.add('text-slate-500', 'border-transparent');

                    pexelsPanel.classList.remove('hidden');
                    uploadPanel.classList.add('hidden');
                    uploadPanel.classList.remove('flex');
                } else {
                    uploadBtn.classList.add('text-orange-600', 'border-orange-600');
                    uploadBtn.classList.remove('text-slate-500', 'border-transparent');
                    pexelsBtn.classList.remove('text-orange-600', 'border-orange-600');
                    pexelsBtn.classList.add('text-slate-500', 'border-transparent');

                    uploadPanel.classList.remove('hidden');
                    uploadPanel.classList.add('flex');
                    pexelsPanel.classList.add('hidden');
                }
            }

            // --- GitHub Upload Logic ---
            function handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('border-orange-400', 'bg-orange-50');

                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    uploadFileToGitHub(e.dataTransfer.files[0]);
                }
            }

            function handleFileSelect(e) {
                if (e.target.files && e.target.files[0]) {
                    uploadFileToGitHub(e.target.files[0]);
                }
            }

            async function uploadFileToGitHub(file) {
                // 1. Check Config
                const ghConfig = JSON.parse(localStorage.getItem('stackpages_github_config') || '{}');
                if (!ghConfig.owner || !ghConfig.repo || !ghConfig.token) {
                    alert("Configuration GitHub manquante. Veuillez la configurer dans le tableau de bord.");
                    return;
                }

                // 2. Prepare UI
                const progressDiv = document.getElementById('upload-progress');
                const progressBar = document.getElementById('upload-bar');
                const progressPercent = document.getElementById('upload-percent');

                progressDiv.classList.remove('hidden');
                progressBar.style.width = '10%';
                progressPercent.textContent = '10%';

                try {
                    // 3. Read File
                    const reader = new FileReader();
                    reader.readAsDataURL(file);

                    reader.onload = async () => {
                        const base64Content = reader.result.split(',')[1];

                        progressBar.style.width = '40%';
                        progressPercent.textContent = '40%';

                        // 4. Generate Filename
                        const timestamp = new Date().getTime();
                        const cleanName = file.name.replace(/[^a-zA-Z0-9.]/g, '-').toLowerCase();
                        const filename = `${timestamp}-${cleanName}`;
                        const path = `content/images/${filename}`;

                        // 5. Upload to GitHub
                        const url = `https://api.github.com/repos/${ghConfig.owner}/${ghConfig.repo}/contents/${path}`;

                        const res = await fetch(url, {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${ghConfig.token}`,
                                'Accept': 'application/vnd.github.v3+json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Upload image: ${filename}`,
                                content: base64Content
                            })
                        });

                        if (!res.ok) {
                            const err = await res.json();
                            throw new Error(err.message);
                        }

                        const data = await res.json();

                        progressBar.style.width = '100%';
                        progressPercent.textContent = '100%';

                        // 6. Insert Image
                        // Use raw.githubusercontent.com or the download_url from response
                        // data.content.download_url is usually the raw link
                        const imageUrl = data.content.download_url;

                        setTimeout(() => {
                            selectImage(imageUrl, file.name);
                            progressDiv.classList.add('hidden');
                            progressBar.style.width = '0%';
                        }, 500);
                    };

                } catch (e) {
                    console.error("Upload Error:", e);
                    alert(`Erreur lors de l'upload: ${e.message}`);
                    progressDiv.classList.add('hidden');
                }
            }

            // Close modal on click outside
            document.getElementById('image-bank-modal').addEventListener('click', (e) => {
                if (e.target.id === 'image-bank-modal') closeImageBank();
            });
        </script>
</body>

</html>